var audioContext = new AudioContext(),
    jungle = new Jungle(audioContext),
    sourcex;
async function play0(blob) {
    var level = (($(".level").val()) / 100);
    var arrayBuffer = await (await fetch(blob)).arrayBuffer();
    let audioBuffer = await (new AudioContext()).decodeAudioData(arrayBuffer);
    sourcex = context.createBufferSource();
    sourcex.buffer = audioBuffer;
    let compressor = context.createDynamicsCompressor();
    node.connect(context.destination);
    sourcex.connect(jungle.input)
    jungle.output.connect(compressor)
    jungle.setPitchOffset(level);
    compressor.connect(context.destination);
    songOnTime = context.currentTime;
    sourcex.start(musicStartPoint);
}
var _audioCtx = null;
var _jungle = null;
var _outputNode = null;
var videoConnected = false;
var _previousPlaybackRate = 1;
var _previousPitch = 0;
var transpose = false;

function getAudioContext() {
    if (!_audioCtx) {
        _audioCtx = new AudioContext();
    }
    return _audioCtx;
}

function getJungle() {
    if (!_jungle) {
        _jungle = new Jungle(getAudioContext());
    }
    return _jungle;
}

function getOutputNode(audio) {
    if (!_outputNode) {
        audioCtx = getAudioContext();
        _outputNode = audioCtx.createMediaElementSource(audio);
    }
    return _outputNode;
}

function connectAudio(audio, Pitch) {
    var audioCtx = getAudioContext();
    if (_outputNode !== undefined && _outputNode !== null) {}
    var outputNode = getOutputNode(audio);
    var jungle = getJungle();
    outputNode.connect(jungle.input);
    jungle.output.connect(audioCtx.destination);
    jungle.setPitchOffset(Pitch, transpose);
}

function disconnectAudio(audio) {
    var audioCtx = getAudioContext();
    var outputNode = getOutputNode(audio);
    var jungle = getJungle();
    outputNode.disconnect(jungle.input);
    jungle.output.disconnect(audioCtx.destination);
    outputNode.connect(audioCtx.destination);
}
var first = true,
    el;

function play() {
    var level = (($(".level").val()) / 100);
    el = document.querySelector("audio");
    connectAudio(el, level);
}

function levelslider(slideEvt) {
    var level = (slideEvt / 100);
    console.log('pitch ', level);
    _jungle.setPitchOffset(level);
}

function pause() {}
var source = {
    extract: function(target, numFrames, position) {
        if (Math.round(100 * position / (bufferDuration * context.sampleRate)) == 100 && is_playing) {
            console.log('Recording complete.');
            if (typeof recorder != "undefined") {}
            is_playing = false;
        }
        var l = buffer.getChannelData(0);
        if (buffer.numberofChannels > 1) {
            var r = buffer.getChannelData(1);
        } else {
            var r = buffer.getChannelData(0);
        }
        for (var i = 0; i < numFrames; i++) {
            target[i * 2] = l[i + position];
            target[i * 2 + 1] = r[i + position];
        }
        return Math.min(numFrames, l.length - position);
    }
};

function stplay(e) {
    play(e);
}

function stpause(e) {}

function minsSecs(secs) {
    mins = Math.floor(secs / 60);
    seconds = secs - mins * 60;
    return mins + ":" + pad(parseInt(seconds), 2);
}

function pad(n, width, z) {
    z = z || '0';
    n = n + '';
    return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}

function startProcess(blob) {
    if (is_playing) pause();
    var uint8ArrayNew = null;
    var arrayBufferNew = null;
    var reader = new FileReader();
    reader.onload = function(ev) {
        arrayBufferNew = ev.target.result;
        uint8ArrayNew = new Uint8Array(arrayBufferNew);
        context.decodeAudioData(ev.target.result, function(theBuffer) {
            pause();
            buffer = theBuffer;
            bufferDuration = theBuffer.duration;
            st = new SoundTouch();
            st.pitch = ($(".level").val() / 100);
            st.tempo = ($(".level").val() / 100);
            f = new SimpleFilter(source, st);
            var BUFFER_SIZE = 2048;
            var node = context.createScriptProcessor ? context.createScriptProcessor(BUFFER_SIZE, 2, 2) : context.createJavaScriptNode(BUFFER_SIZE, 2, 2);
            var samples = new Float32Array(BUFFER_SIZE * 2);
            var pos = 0;
            f.sourcePosition = 0;
        }, function() {
            console.log("Sorry, we could not process this audio file.");
        })
    };
    reader.readAsArrayBuffer(blob);
}
var recorderx;
const stsend = async function(blob) {
    var arrayBuffer = await (await fetch(blob)).arrayBuffer();
    let audioBuffer = await (new AudioContext()).decodeAudioData(arrayBuffer);
    let ctx = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
    let sourcex = ctx.createBufferSource();
    sourcex.buffer = audioBuffer;
    let jungle = new Jungle(ctx);
    let compressor = ctx.createDynamicsCompressor();
    sourcex.connect(jungle.input)
    jungle.output.connect(compressor)
    jungle.setPitchOffset(($(".level").val()) / 100)
    recorderx = new Recorder(compressor, {
        workerPath: './js/recorderWorkerMP3.js'
    });
    await recorderx && recorderx.record();
    compressor.connect(ctx.destination);
    sourcex.start(0);
    return await ctx.startRendering();
}
